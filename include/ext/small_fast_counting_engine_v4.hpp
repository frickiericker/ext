/*
 * A good random number engine.
 *
 * Distributed under the Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 */
#ifndef EXT_SMALL_FAST_COUNTING_ENGINE_V4_HPP
#define EXT_SMALL_FAST_COUNTING_ENGINE_V4_HPP

#include <algorithm>
#include <array>
#include <istream>
#include <limits>
#include <ostream>
#include <random>
#include <type_traits>

#include <cassert>
#include <cstddef>
#include <cstdint>

#include "bit_utility.hpp"
#include "random_utility.hpp"
#include "stream_utility.hpp"

namespace ext
{
    /**
     * Small fast counting random number generator version 4 from PractRand.
     */
    template<typename Word,
             unsigned BarrelShift,
             unsigned RightShift,
             unsigned LeftShift,
             unsigned long long InitialRound>
    struct small_fast_counting_engine_v4
    {
        //----------------------------------------------------------------------
        // Engine characteristics
        //----------------------------------------------------------------------

        /*
         * Unsigned integral type of the numbers generated by the engine. This
         * is an alias of the template argument Word.
         */
        using result_type = Word;

        static_assert(std::is_unsigned<result_type>::value,
                      "invalid word type");

        /*
         * Parameters of the engine.
         */
        static constexpr unsigned barrel_shift = BarrelShift;
        static constexpr unsigned right_shift = RightShift;
        static constexpr unsigned left_shift = LeftShift;
        static constexpr unsigned long long initial_round = InitialRound;
        static constexpr result_type default_seed = 0;

        /*
         * Returns the minimum value potentially generated by the engine.
         */
        static constexpr
        result_type min() noexcept
        {
            return 0;
        }

        /*
         * Returns the maxmimum value potentially generated by the engine.
         */
        static constexpr
        result_type max() noexcept
        {
            return std::numeric_limits<result_type>::max();
        }

      private:
        static constexpr result_type word_bits
                = std::numeric_limits<result_type>::digits;
        static_assert(barrel_shift < word_bits, "parameter out of range");
        static_assert(right_shift < word_bits, "parameter out of range");
        static_assert(left_shift < word_bits, "parameter out of range");

      public:

        //----------------------------------------------------------------------
        // Construction and seeding
        //----------------------------------------------------------------------

        /*
         * Constructs the pseudo-random number generator engine whose internal
         * state is initialized using given seed.
         */
        explicit constexpr
        small_fast_counting_engine_v4(
                result_type seed_val = default_seed) noexcept
        {
            seed(seed_val);
        }

        template<typename Seed,
                 std::enable_if_t<ext::is_seed_sequence<Seed>::value, int> = 0>
        explicit
        small_fast_counting_engine_v4(Seed& seed_seq)
        {
            seed(seed_seq);
        }

        /*
         * Initializes the state of the engine using given seed value.
         */
        constexpr
        void seed(result_type seed_val = default_seed) noexcept
        {
            counter_ = 1;
            state_a_ = state_b_ = state_c_ = seed_val;
            discard(initial_round);
        }

        /*
         * Initializes the state of the engine using seed values generated by
         * given seed sequence.
         */
        template<typename Seed,
                 std::enable_if_t<ext::is_seed_sequence<Seed>::value, int> = 0>
        void seed(Seed& seed_seq)
        {
            std::array<result_type, 3> tmp;
            ext::seed_state(seed_seq, tmp);
            state_a_ = tmp[0];
            state_b_ = tmp[1];
            state_c_ = tmp[2];
            counter_ = 1;

            discard(initial_round);
        }

        //----------------------------------------------------------------------
        // Random number generation
        //----------------------------------------------------------------------

        /*
         * Advances the state of the engine and returns a pseudo-random value.
         */
        constexpr
        result_type operator()() noexcept
        {
            auto& counter = counter_;
            auto& a = state_a_;
            auto& b = state_b_;
            auto& c = state_c_;

            auto const tmp = result_type(a + b + counter++);
            a = b ^ result_type(b >> right_shift);
            b = c + result_type(c << left_shift);
            c = ext::rotate(c, barrel_shift) + tmp;

            return tmp;
        }

        /*
         * Advances the state of the engine z times.
         */
        constexpr
        void discard(unsigned long long z) noexcept
        {
            for (; z != 0; --z)
            {
                (*this)();
            }
        }

        //----------------------------------------------------------------------
        // Comparison operators
        //----------------------------------------------------------------------

        /*
         * Compares the internal states of given engines for equality.
         */
        friend constexpr
        bool operator==(small_fast_counting_engine_v4 const& x,
                        small_fast_counting_engine_v4 const& y) noexcept
        {
            return x.state_a_ == y.state_a_ &&
                   x.state_b_ == y.state_b_ &&
                   x.state_c_ == y.state_c_ &&
                   x.counter_ == y.counter_;
        }

        friend constexpr
        bool operator!=(small_fast_counting_engine_v4 const& x,
                        small_fast_counting_engine_v4 const& y) noexcept
        {
            return !(x == y);
        }

        //----------------------------------------------------------------------
        // State I/O
        //----------------------------------------------------------------------

        /**
         * Writes state to stream.
         *
         * The a, b, c, and counter values are written to the stream in left-
         * aligned decimal format in this order using single space character as
         * delimiter.
         */
        template<typename Char, typename CharTraits>
        friend
        std::basic_ostream<Char, CharTraits>&
        operator<<(std::basic_ostream<Char, CharTraits>& output_stream,
                   small_fast_counting_engine_v4 const& engine)
        {
            ext::save_stream_flags flags {output_stream};
            output_stream.flags(std::ios::dec | std::ios::left);
            output_stream.fill(space);

            Char const space = output_stream.widen(' ');
            output_stream << engine.state_a_ << space
                          << engine.state_b_ << space
                          << engine.state_c_ << space
                          << engine.counter_;

            return output_stream;
        }

        /*
         * Restores state from stream.
         *
         * Reads serialized representation from the input stream. The state
         * of the engine does not change upon failure.
         */
        template<typename Char, typename CharTraits>
        friend
        std::basic_istream<Char, CharTraits>&
        operator>>(std::basic_istream<Char, CharTraits>& input_stream,
                   small_fast_counting_engine_v4& engine)
        {
            ext::save_stream_flags flags {output_stream};
            input_stream.flags(std::ios::dec | std::ios::skipws);

            std::array<result_type, 4> tmp;
            if (input_stream >> tmp[0] >> tmp[1] >> tmp[2] >> tmp[3])
            {
                engine.state_a_ = tmp[0];
                engine.state_b_ = tmp[1];
                engine.state_c_ = tmp[2];
                engine.counter_ = tmp[3];
            }

            return input_stream;
        }

        //----------------------------------------------------------------------
      private:
        result_type state_a_ = 0;
        result_type state_b_ = 0;
        result_type state_c_ = 0;
        result_type counter_ = 0;
    };

    /*
     * Instantiations of small_fast_counting_engine_v4 with parameters found in
     * PractRand.
     */
    using sfc16 = small_fast_counting_engine_v4<std::uint16_t,  7,  3, 2, 12>;
    using sfc32 = small_fast_counting_engine_v4<std::uint32_t, 25,  8, 3, 12>;
    using sfc64 = small_fast_counting_engine_v4<std::uint64_t, 25, 12, 3, 12>;
}

#endif
