#ifndef EXT_RANDOM_HPP
#define EXT_RANDOM_HPP

#include <algorithm>
#include <array>
#include <ios>
#include <istream>
#include <iterator>
#include <limits>
#include <ostream>
#include <random>
#include <type_traits>
#include <utility>

#include <cmath>
#include <cstddef>
#include <cstdint>

#include "meta.hpp"
#include "stream.hpp"


//____ Metafunction __________________________________________________________

namespace ext
{
    namespace random_detail
    {
        template<typename S>
        auto try_seed_seq_generate(
                S&             q  = std::declval<S&>(),
                unsigned long* ib = std::declval<unsigned long*>(),
                unsigned long* ie = std::declval<unsigned long*>()
                )
            -> decltype(q.generate(ib, ie));

        template<typename T>
        using seed_seq_generate_t = decltype(try_seed_seq_generate<T>());
    }

    /*
     * Determines whether T satisfies the seed sequence requirements.
     */
    template<typename T>
    struct is_seed_sequence : n4502::is_detected<random_detail::seed_seq_generate_t, T>
    {
    };
}

//____ Engine ________________________________________________________________

namespace ext
{
    namespace random_detail
    {
        template<typename T>
        struct seed_extender;

        template<>
        struct seed_extender<std::uint64_t>
        {
            using result_type = std::uint64_t;

            explicit constexpr
            seed_extender(result_type seed)
                : xorshift_1_(seed)
                , xorshift_2_(~seed)
            {
            }

            constexpr
            result_type operator()() noexcept
            {
                auto& x = xorshift_1_;
                auto& y = xorshift_2_;

                // xorshift64*
                constexpr auto shift_1 = 12;
                constexpr auto shift_2 = 25;
                constexpr auto shift_3 = 27;
                constexpr auto multiplier = result_type{2685821657736338717};

                x ^= x >> shift_1;
                x ^= x << shift_2;
                x ^= x >> shift_3;
                auto const u = x * multiplier;

                y ^= y >> shift_1;
                y ^= y << shift_2;
                y ^= y >> shift_3;
                auto const v = y * multiplier;

                // This expression must be assymetric with respect to u and v.
                // Otherwise seed_extender(s) and seed_extender(~s) generates
                // identical sequence for any s.
                return ~u + v;
            }

          private:

            result_type xorshift_1_;
            result_type xorshift_2_;
        };
    }
}

namespace ext
{
    /*
     * The xorshift* pseudo-random number generator.
     *
     * http://xorshift.di.unimi.it/
     */
    template< typename Word
            , std::size_t StateSize
            , unsigned Shift_1
            , unsigned Shift_2
            , unsigned Shift_3
            , Word Multiplier
            , typename SeedExtender>
    struct xorshift_star_engine
    {
        //__ engine characteristics __________________________________________

        /*
         * The unsigned integral type generated by the engine. This is an
         * alias of the template argument Word.
         */
        using result_type = Word;

        /*
         * Type of seed extender used to fill internal state using single seed
         * value.
         */
        using seed_extender = SeedExtender;

        /*
         * The parameters of the engine.
         */
        static constexpr std::size_t state_size = StateSize;
        static constexpr unsigned shift_1 = Shift_1;
        static constexpr unsigned shift_2 = Shift_2;
        static constexpr unsigned shift_3 = Shift_3;
        static constexpr result_type multiplier = Multiplier;

        /*
         * Returns the minimum value potentially generated by the engine.
         */
        static constexpr
        result_type min() noexcept
        {
            return 0;
        }

        /*
         * Returns the maxmimum value potentially generated by the engine.
         */
        static constexpr
        result_type max() noexcept
        {
            return std::numeric_limits<result_type>::max();
        }

        /*
         * Default seed value used when constructor or seed function is called
         * with no argument.
         */
        static constexpr result_type default_seed = 0;

      private:

        static_assert(state_size != 0, "state size cannot be zero");

        static constexpr auto word_bits = std::numeric_limits<result_type>::digits;
        static_assert(shift_1 < word_bits, "parameter out of range");
        static_assert(shift_2 < word_bits, "parameter out of range");
        static_assert(shift_3 < word_bits, "parameter out of range");

        using position_type = typename std::array<result_type, state_size>::size_type;

      public:

        //__ construction and seeding ________________________________________

        /*
         * Constructs the pseudo-random number generator engine whose internal
         * state is initialized using given seed.
         */
        explicit constexpr
        xorshift_star_engine(result_type seed_val = default_seed) noexcept
        {
            seed(seed_val);
        }

        template< typename SeedSeq
                , std::enable_if_t<ext::is_seed_sequence<SeedSeq>::value, int> = 0>
        explicit
        xorshift_star_engine(SeedSeq& seed_seq)
        {
            seed(seed_seq);
        }

        /*
         * Initializes the state of the engine using given seed value.
         */
        constexpr
        void seed(result_type seed_val = default_seed) noexcept
        {
            auto seeder = seed_extender(seed_val);
            for (auto& x : state_)
                x = seeder();
            position_ = 0;
        }

        /*
         * Initializes the state of the engine using seed values generated by
         * given seed sequence.
         */
        template< typename SeedSeq
                , std::enable_if_t<ext::is_seed_sequence<SeedSeq>::value, int> = 0>
        void seed(SeedSeq& seed_seq)
        {
            // SeedSeq generates 32-bit uints. Convert them to words.
            constexpr std::size_t seed_per_word = (word_bits + 31) / 32;

            std::array<std::uint_least32_t, seed_per_word * state_size> seeds;
            seed_seq.generate(std::begin(seeds), std::end(seeds));

            for (std::size_t state_index = 0; state_index < state_size; ++state_index)
            {
                state_[state_index] = 0;
                for (std::size_t subseed_index = 0; subseed_index < seed_per_word; ++subseed_index)
                {
                    auto const subseed = seeds[seed_per_word * state_index + subseed_index];
                    (state_[state_index] <<= 32) |= static_cast<result_type>(subseed);
                }
            }
            position_ = 0;
        }

        //__ generation ______________________________________________________

        /*
         * Advances the state of the engine and returns a pseudo-random value.
         */
        constexpr
        result_type operator()() noexcept
        {
            auto& s = state_;
            auto& p = position_;

            auto s0 = s[p];
            auto s1 = s[++p %= state_size];
            s1 ^= s1 << shift_1;
            s1 ^= s1 >> shift_2;
            s0 ^= s0 >> shift_3;
            s[p] = s0 ^ s1;

            return s[p] * multiplier;
        }

        /*
         * Advances the state of the engine z times.
         */
        constexpr
        void discard(unsigned long long z) noexcept
        {
            for (; z != 0; --z)
                (*this)();
        }

        //__ comparison operators ____________________________________________

        /*
         * Compares the internal states of given engines for equality.
         */
        friend constexpr
        bool operator==(xorshift_star_engine const& x,
                        xorshift_star_engine const& y) noexcept
        {
            return x.state_ == y.state_;
        }

        friend constexpr
        bool operator!=(xorshift_star_engine const& x,
                        xorshift_star_engine const& y) noexcept
        {
            return !(x == y);
        }

        //__ state input/output ______________________________________________

        /*
         * Dumps state variables to output stream. The a, b, c, and counter
         * values are written to the stream in left-aligned decimal format in
         * this order using single space character as delimiter.
         */
        template<typename Char, typename CharTraits>
        friend
        std::basic_ostream<Char, CharTraits>&
        operator<<(std::basic_ostream<Char, CharTraits>& output_stream,
                   xorshift_star_engine const& engine)
        {
            auto const space = output_stream.widen(' ');

            auto restorer = ext::save_stream_flags(output_stream);
            output_stream.flags(std::ios::dec | std::ios::left);
            output_stream.fill(space);

            output_stream << engine.state_[0];
            for (std::size_t index = 1; index < state_size; ++index)
                output_stream << space << engine.state_[index];

            return output_stream;
        }

        /*
         * Restores state variables from the serialized representation in the
         * input stream. The state of the engine does not change upon failure.
         */
        template<typename Char, typename CharTraits>
        friend
        std::basic_istream<Char, CharTraits>&
        operator>>(std::basic_istream<Char, CharTraits>& input_stream,
                   xorshift_star_engine& engine)
        {
            auto restorer = ext::save_stream_flags(input_stream);
            input_stream.flags(std::ios::dec | std::ios::skipws);

            std::array<result_type, state_size> tmp;
            for (auto& x : tmp)
                input_stream >> x;
            if (input_stream)
                engine.state_ = tmp;

            return input_stream;
        }

      private:

        // Must be initialized to be usable in constexpr context.
        std::array<result_type, state_size> state_ = {};
        position_type position_ = 0;
    };

    /*
     * xorshift1024*
     */
    using xorshift1024_star = xorshift_star_engine<
            std::uint64_t, 16,
            31, 11, 30,
            1181783497276652981,
            random_detail::seed_extender<std::uint64_t>>;


    namespace detail
    {
        /*
         * Calculates left rotation (or barrel shift) of unsigned integer.
         * Behavior is undefined if n is greater than the bit width of the
         * integral type.
         */
        template<typename Integer>
        constexpr
        Integer rotate(Integer x, unsigned n)
        {
            constexpr auto bits = std::numeric_limits<Integer>::digits;

            // (x >> bits) is UB. See http://stackoverflow.com/q/18918256
            if (n == 0)
                return x;
            else
                return Integer(x << n) | Integer(x >> (bits - n));
        }
    }

    /*
     * A small fast pseudo-random number generator found in [1].
     *
     * [1] http://burtleburtle.net/bob/rand/smallprng.html
     */
    template<typename Word,
             unsigned Rotation_1,
             unsigned Rotation_2,
             unsigned Rotation_3,
             Word     FixedSeed,
             unsigned long long InitialRound>
    struct jenkins_small_fast_engine
    {
        //__ engine characteristics __________________________________________

        /*
         * The unsigned integral type generated by the engine. This is an
         * alias of the template argument Word.
         */
        using result_type = Word;

        /*
         * The parameters of the engine.
         */
        static constexpr unsigned rotation_1 = Rotation_1;
        static constexpr unsigned rotation_2 = Rotation_2;
        static constexpr unsigned rotation_3 = Rotation_3;
        static constexpr result_type fixed_seed = FixedSeed;
        static constexpr unsigned long long initial_round = InitialRound;

        /*
         * Returns the minimum value potentially generated by the engine.
         */
        static constexpr
        result_type min() noexcept
        {
            return 0;
        }

        /*
         * Returns the maxmimum value potentially generated by the engine.
         */
        static constexpr
        result_type max() noexcept
        {
            return std::numeric_limits<result_type>::max();
        }

        /*
         * Default seed value used when constructor or seed function is called
         * with no argument.
         */
        static constexpr result_type default_seed = 0;

      private:

        static constexpr auto word_bits = std::numeric_limits<result_type>::digits;
        static_assert(rotation_1 < word_bits, "parameter out of range");
        static_assert(rotation_2 < word_bits, "parameter out of range");
        static_assert(rotation_3 < word_bits, "parameter out of range");

      public:

        //__ construction and seeding ________________________________________

        /*
         * Constructs the pseudo-random number generator engine whose internal
         * state is initialized using given seed.
         */
        explicit constexpr
        jenkins_small_fast_engine(result_type seed_val = default_seed) noexcept
        {
            seed(seed_val);
        }

        template< typename SeedSeq
                , std::enable_if_t<ext::is_seed_sequence<SeedSeq>::value, int> = 0>
        explicit
        jenkins_small_fast_engine(SeedSeq& seed_seq)
        {
            seed(seed_seq);
        }

        /*
         * Initializes the state of the engine using given seed value.
         */
        constexpr
        void seed(result_type seed_val = default_seed) noexcept
        {
            state_a_ = fixed_seed;
            state_b_ = state_c_ = state_d_ = seed_val;
            discard(initial_round);
        }

        /*
         * Initializes the state of the engine using seed values generated by
         * given seed sequence.
         */
        template< typename SeedSeq
                , std::enable_if_t<ext::is_seed_sequence<SeedSeq>::value, int> = 0>
        void seed(SeedSeq& seed_seq)
        {
            state_a_ = fixed_seed;

            // SeedSeq generates 32-bit uints. Convert them to words.
            constexpr std::size_t seed_per_word = (word_bits + 31) / 32;

            std::uint_least32_t seeds[3 * seed_per_word];
            seed_seq.generate(std::begin(seeds), std::end(seeds));

            state_b_ = 0;
            state_c_ = 0;
            state_d_ = 0;
            for (std::size_t seed_index = 0; seed_index < seed_per_word; ++seed_index)
            {
                (state_b_ <<= 32) |= static_cast<result_type>(seeds[3 * seed_index + 0]);
                (state_c_ <<= 32) |= static_cast<result_type>(seeds[3 * seed_index + 1]);
                (state_d_ <<= 32) |= static_cast<result_type>(seeds[3 * seed_index + 2]);
            }

            discard(initial_round);
        }

        //__ generation ______________________________________________________

        /*
         * Advances the state of the engine and returns a pseudo-random value.
         */
        constexpr
        result_type operator()() noexcept
        {
            using detail::rotate;

            auto& a = state_a_;
            auto& b = state_b_;
            auto& c = state_c_;
            auto& d = state_d_;

            auto const e = a - rotate(b, rotation_1);
            a = b ^ rotate(c, rotation_2);
            b = c + rotate(d, rotation_3);
            c = d + e;
            d = e + a;

            return d;
        }

        /*
         * Advances the state of the engine z times.
         */
        constexpr
        void discard(unsigned long long z) noexcept
        {
            for (; z != 0; --z)
                (*this)();
        }

        //__ comparison operators ____________________________________________

        /*
         * Compares the internal states of given engines for equality.
         */
        friend constexpr
        bool operator==(jenkins_small_fast_engine const& x,
                        jenkins_small_fast_engine const& y) noexcept
        {
            return x.state_a_ == y.state_a_ &&
                   x.state_b_ == y.state_b_ &&
                   x.state_c_ == y.state_c_ &&
                   x.state_d_ == y.state_d_;
        }

        friend constexpr
        bool operator!=(jenkins_small_fast_engine const& x,
                        jenkins_small_fast_engine const& y)
        {
            return !(x == y);
        }

        //__ state input/output ______________________________________________

        /*
         * Dumps state variables to output stream. The a, b, c, and d values
         * are written to the stream in left-aligned decimal format in this
         * order using single space character as delimiter.
         */
        template<typename Char, typename CharTraits>
        friend
        std::basic_ostream<Char, CharTraits>&
        operator<<(std::basic_ostream<Char, CharTraits>& output_stream,
                   jenkins_small_fast_engine const& engine)
        {
            auto const space = output_stream.widen(' ');

            auto restorer = ext::save_stream_flags(output_stream);
            output_stream.flags(std::ios::dec | std::ios::left);
            output_stream.fill(space);

            output_stream << engine.state_a_ << space
                          << engine.state_b_ << space
                          << engine.state_c_ << space
                          << engine.state_d_;

            return output_stream;
        }

        /*
         * Restores state variables from the serialized representation in the
         * input stream. The state of the engine does not change upon failure.
         */
        template<typename Char, typename CharTraits>
        friend
        std::basic_istream<Char, CharTraits>&
        operator>>(std::basic_istream<Char, CharTraits>& input_stream,
                   jenkins_small_fast_engine& engine)
        {
            auto restorer = ext::save_stream_flags(input_stream);
            input_stream.flags(std::ios::dec | std::ios::skipws);

            result_type tmp[4];
            if (input_stream >> tmp[0] >> tmp[1] >> tmp[2] >> tmp[3])
            {
                engine.state_a_ = tmp[0];
                engine.state_b_ = tmp[1];
                engine.state_c_ = tmp[2];
                engine.state_d_ = tmp[3];
            }

            return input_stream;
        }

      private:

        // Must be initialized to be usable in constexpr context.
        result_type state_a_ = 0;
        result_type state_b_ = 0;
        result_type state_c_ = 0;
        result_type state_d_ = 0;
    };

    /*
     * Instantiation of jenkins_small_fast_engine with parameters found in the
     * website [1] of the author of the algorithm.
     *
     * [1] http://burtleburtle.net/bob/rand/smallprng.html
     */
    using jsf32 = jenkins_small_fast_engine<std::uint32_t, 27, 17, 0, 0xf1ea5eed, 20>;
    using jsf64 = jenkins_small_fast_engine<std::uint64_t, 39, 11, 0, 0xf1ea5eed, 20>;


    /*
     * Small Fast Counting RNG version 4 from PractRand.
     */
    template<typename Word,
             unsigned BarrelShift,
             unsigned RightShift,
             unsigned LeftShift,
             unsigned long long InitialRound>
    struct small_fast_counting_engine_v4
    {
        //__ engine characteristics __________________________________________

        /*
         * The unsigned integral type generated by the engine. This is an
         * alias of the template argument Word.
         */
        using result_type = Word;

        static_assert(std::is_unsigned<result_type>::value, "invalid word type");

        /*
         * The parameters of the engine.
         */
        static constexpr unsigned barrel_shift = BarrelShift;
        static constexpr unsigned right_shift = RightShift;
        static constexpr unsigned left_shift = LeftShift;
        static constexpr unsigned long long initial_round = InitialRound;

        /*
         * Returns the minimum value potentially generated by the engine.
         */
        static constexpr
        result_type min() noexcept
        {
            return 0;
        }

        /*
         * Returns the maxmimum value potentially generated by the engine.
         */
        static constexpr
        result_type max() noexcept
        {
            return std::numeric_limits<result_type>::max();
        }

        /*
         * Default seed value used when constructor or seed function is called
         * with no argument.
         */
        static constexpr result_type default_seed = 0;

      private:

        static constexpr auto word_bits = std::numeric_limits<result_type>::digits;
        static_assert(barrel_shift < word_bits, "parameter out of range");
        static_assert(right_shift < word_bits, "parameter out of range");
        static_assert(left_shift < word_bits, "parameter out of range");

      public:

        //__ construction and seeding ________________________________________

        /*
         * Constructs the pseudo-random number generator engine whose internal
         * state is initialized using given seed.
         */
        explicit constexpr
        small_fast_counting_engine_v4(result_type seed_val = default_seed) noexcept
        {
            seed(seed_val);
        }

        template< typename SeedSeq
                , std::enable_if_t<ext::is_seed_sequence<SeedSeq>::value, int> = 0>
        explicit
        small_fast_counting_engine_v4(SeedSeq& seed_seq)
        {
            seed(seed_seq);
        }

        /*
         * Initializes the state of the engine using given seed value.
         */
        constexpr
        void seed(result_type seed_val = default_seed) noexcept
        {
            counter_ = 1;
            state_a_ = state_b_ = state_c_ = seed_val;
            discard(initial_round);
        }

        /*
         * Initializes the state of the engine using seed values generated by
         * given seed sequence.
         */
        template< typename SeedSeq
                , std::enable_if_t<ext::is_seed_sequence<SeedSeq>::value, int> = 0>
        void seed(SeedSeq& seed_seq)
        {
            counter_ = 1;

            // SeedSeq generates 32-bit unsigned integers. Convert them to
            // words, then fill state variables.
            constexpr std::size_t seed_per_word = (word_bits + 31) / 32;

            std::uint_least32_t seeds[3 * seed_per_word];
            seed_seq.generate(std::begin(seeds), std::end(seeds));

            state_a_ = 0;
            state_b_ = 0;
            state_c_ = 0;
            for (std::size_t seed_index = 0; seed_index < seed_per_word; ++seed_index)
            {
                (state_a_ <<= 32) |= static_cast<result_type>(seeds[3 * seed_index + 0]);
                (state_b_ <<= 32) |= static_cast<result_type>(seeds[3 * seed_index + 1]);
                (state_c_ <<= 32) |= static_cast<result_type>(seeds[3 * seed_index + 2]);
            }

            discard(initial_round);
        }

        //__ generation ______________________________________________________

        /*
         * Advances the state of the engine and returns a pseudo-random value.
         */
        constexpr
        result_type operator()() noexcept
        {
            using detail::rotate;

            auto& counter = counter_;
            auto& a = state_a_;
            auto& b = state_b_;
            auto& c = state_c_;

            auto const tmp = result_type(a + b + counter++);
            a = b ^ result_type(b >> right_shift);
            b = c + result_type(c << left_shift);
            c = rotate(c, barrel_shift) + tmp;

            return tmp;
        }

        /*
         * Advances the state of the engine z times.
         */
        constexpr
        void discard(unsigned long long z) noexcept
        {
            for (; z != 0; --z)
                (*this)();
        }

        //__ comparison operators ____________________________________________

        /*
         * Compares the internal states of given engines for equality.
         */
        friend constexpr
        bool operator==(small_fast_counting_engine_v4 const& x,
                        small_fast_counting_engine_v4 const& y) noexcept
        {
            return x.state_a_ == y.state_a_ &&
                   x.state_b_ == y.state_b_ &&
                   x.state_c_ == y.state_c_ &&
                   x.counter_ == y.counter_;
        }

        friend constexpr
        bool operator!=(small_fast_counting_engine_v4 const& x,
                        small_fast_counting_engine_v4 const& y) noexcept
        {
            return !(x == y);
        }

        //__ state input/output ______________________________________________

        /*
         * Dumps state variables to output stream. The a, b, c, and counter
         * values are written to the stream in left-aligned decimal format in
         * this order using single space character as delimiter.
         */
        template<typename Char, typename CharTraits>
        friend
        std::basic_ostream<Char, CharTraits>&
        operator<<(std::basic_ostream<Char, CharTraits>& output_stream,
                   small_fast_counting_engine_v4 const& engine)
        {
            auto const space = output_stream.widen(' ');

            auto restorer = ext::save_stream_flags(output_stream);
            output_stream.flags(std::ios::dec | std::ios::left);
            output_stream.fill(space);

            output_stream << engine.state_a_ << space
                          << engine.state_b_ << space
                          << engine.state_c_ << space
                          << engine.counter_;

            return output_stream;
        }

        /*
         * Restores state variables from the serialized representation in the
         * input stream. The state of the engine does not change upon failure.
         */
        template<typename Char, typename CharTraits>
        friend
        std::basic_istream<Char, CharTraits>&
        operator>>(std::basic_istream<Char, CharTraits>& input_stream,
                   small_fast_counting_engine_v4& engine)
        {
            auto restorer = ext::save_stream_flags(input_stream);
            input_stream.flags(std::ios::dec | std::ios::skipws);

            result_type tmp[4];
            if (input_stream >> tmp[0] >> tmp[1] >> tmp[2] >> tmp[3])
            {
                engine.state_a_ = tmp[0];
                engine.state_b_ = tmp[1];
                engine.state_c_ = tmp[2];
                engine.counter_ = tmp[3];
            }

            return input_stream;
        }

        //____________________________________________________________________

      private:

        // Must be initialized to be usable in constexpr context.
        result_type state_a_ = 0;
        result_type state_b_ = 0;
        result_type state_c_ = 0;
        result_type counter_ = 0;
    };

    /*
     * Instantiation of small_fast_counting_engine_v4 with parameters found
     * in PractRand.
     */
    using sfc16 = small_fast_counting_engine_v4<std::uint16_t,  7,  3, 2, 12>;
    using sfc32 = small_fast_counting_engine_v4<std::uint32_t, 25,  8, 3, 12>;
    using sfc64 = small_fast_counting_engine_v4<std::uint64_t, 25, 12, 3, 12>;
}

//____ Algorithm _____________________________________________________________

namespace ext
{
    template<typename T, std::size_t bits = std::numeric_limits<T>::digits / 2,
             typename RNG>
    T generate_normal(RNG& random_engine)
    {
        using std::abs;
        using std::log;
        using std::sqrt;

        auto const v_factor = T(sqrt(2 / M_E) * 2);

        for (;;)
        {
            auto u = std::generate_canonical<T, bits>(random_engine);
            auto v = std::generate_canonical<T, bits>(random_engine);

            v = v_factor * (v - T(0.5));

            // Numerical Recipes here.
            //
            // Use certain elliptic curves enclosing and covered by the
            // acceptance region to reduce necessity of calculating the
            // exact boundary of the region.
            //
            // NOTE: 1.9x speedup on IvyBridge. Without this optimization
            // ratio-of-uniforms performs worse than cached Box-Muller.

            auto x = u - T(0.449871);
            auto y = abs(v) + T(0.386595);
            auto q = x*x + y*(T(0.19600)*y - T(0.25472)*x);

            if (q > T(0.27597) && (q > T(0.27846) || v*v > -4 * (u*u) * log(u)))
                continue;

            return v / u;
        }
    }
}

#endif
